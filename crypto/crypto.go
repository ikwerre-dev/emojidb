package crypto

import (
	"bufio"
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"errors"
	"io"
	"sort"
	"strings"
)

var (
	EmojiAlphabet = []string{
		"ğŸ˜€", "ğŸ˜", "ğŸ˜‚", "ğŸ¤£", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜…", "ğŸ˜†", "ğŸ˜‰", "ğŸ˜Š", "ğŸ˜‹", "ğŸ˜", "ğŸ˜", "ğŸ˜˜", "ğŸ¥°", "ğŸ˜—",
		"ğŸ˜™", "ğŸ˜š", "â˜ºï¸", "ğŸ™‚", "ğŸ¤—", "ğŸ¤©", "ğŸ¤”", "ğŸ¤¨", "ğŸ˜", "ğŸ˜‘", "ğŸ˜¶", "ğŸ™„", "ğŸ˜", "ğŸ˜£", "ğŸ˜¥", "ğŸ˜®",
		"ğŸ¤", "ğŸ˜¯", "ğŸ˜ª", "ğŸ˜«", "ğŸ˜´", "ğŸ˜Œ", "ğŸ˜›", "ğŸ˜œ", "ğŸ˜", "ğŸ¤¤", "ğŸ˜’", "ğŸ˜“", "ğŸ˜”", "ğŸ˜•", "ğŸ™ƒ", "ğŸ¤‘",
		"ğŸ˜²", "â˜¹ï¸", "ğŸ™", "ğŸ˜–", "ğŸ˜", "ğŸ˜Ÿ", "ğŸ˜¤", "ğŸ˜¢", "ğŸ˜­", "ğŸ˜¦", "ğŸ˜§", "ğŸ˜¨", "ğŸ˜©", "ğŸ¤¯", "ğŸ˜¬", "ğŸ˜°",
		"ğŸ˜±", "ğŸ¥µ", "ğŸ¥¶", "ğŸ˜³", "ğŸ¤ª", "ğŸ˜µ", "ğŸ˜¡", "ğŸ˜ ", "ğŸ¤¬", "ğŸ˜·", "ğŸ¤’", "ğŸ¤•", "ğŸ¤¢", "ğŸ¤®", "ğŸ¤§", "ğŸ˜‡",
		"ğŸ¤ ", "ğŸ¤¡", "ğŸ¥³", "ğŸ¥´", "ğŸ¥º", "ğŸ¤¥", "ğŸ¤«", "ğŸ¤­", "ğŸ§", "ğŸ¤“", "ğŸ˜ˆ", "ğŸ‘¿", "ğŸ‘¹", "ğŸ‘º", "ğŸ’€", "ğŸ‘»",
		"ğŸ‘½", "ğŸ¤–", "ğŸ’©", "ğŸ˜º", "ğŸ˜¸", "ğŸ˜¹", "ğŸ˜»", "ğŸ˜¼", "ğŸ˜½", "ğŸ™€", "ğŸ˜¿", "ğŸ˜¾", "ğŸ™ˆ", "ğŸ™‰", "ğŸ™Š", "ğŸ’‹",
		"ğŸ’Œ", "ğŸ’˜", "ğŸ’", "ğŸ’–", "ğŸ’—", "ğŸ’“", "ğŸ’", "ğŸ’•", "ğŸ’Ÿ", "â£ï¸", "ğŸ’”", "â¤ï¸", "ğŸ§¡", "ğŸ’›", "ğŸ’š", "ğŸ’™",
		"ğŸ’œ", "ğŸ¤", "ğŸ–¤", "ğŸ¤", "ğŸ’¯", "ğŸ’¢", "ğŸ’¥", "ğŸ’«", "ğŸ’¦", "ğŸ’¨", "ğŸ•³ï¸", "ğŸ’£", "ğŸ’¬", "ğŸ‘ï¸â€ğŸ—¨ï¸", "ğŸ—¨ï¸", "ğŸ—¯ï¸",
		"ğŸ’­", "ğŸ’¤", "ğŸ‘‹", "ğŸ¤š", "ğŸ–ï¸", "âœ‹", "ğŸ––", "ğŸ‘Œ", "ğŸ¤", "âœŒï¸", "ğŸ¤", "ğŸ¤Ÿ", "ğŸ¤˜", "ğŸ¤™", "ğŸ‘ˆ", "ğŸ‘‰",
		"ğŸ‘†", "ğŸ–•", "ğŸ‘‡", "â˜ï¸", "ğŸ‘", "ğŸ‘", "âœŠ", "ğŸ‘Š", "ğŸ¤›", "ğŸ¤œ", "ğŸ‘", "ğŸ™Œ", "ğŸ‘", "ğŸ¤²", "ğŸ¤", "ğŸ™",
		"âœï¸", "ğŸ’…", "ğŸ¤³", "ğŸ’ª", "ğŸ¦¾", "ğŸ¦µ", "ğŸ¦¿", "ğŸ‘£", "ğŸ‘‚", "ğŸ¦»", "ğŸ‘ƒ", "ğŸ§ ", "ğŸ¦·", "ğŸ¦´", "ğŸ‘€", "ğŸ‘ï¸",
		"ğŸ‘…", "ğŸ‘„", "ğŸ‘¶", "ğŸ§’", "ğŸ‘¦", "ğŸ‘§", "ğŸ§‘", "ğŸ‘±", "ğŸ‘¨", "ğŸ§”", "ğŸ‘©", "ğŸ§“", "ğŸ‘´", "ğŸ‘µ", "ğŸ‘¨â€âš•ï¸", "ğŸ‘©â€âš•ï¸",
		"ğŸ‘¨â€ğŸ“", "ğŸ‘©â€ğŸ“", "ğŸ‘¨â€ğŸ«", "ğŸ‘©â€ğŸ«", "ğŸ‘¨â€âš–ï¸", "ğŸ‘©â€âš–ï¸", "ğŸ‘¨â€ğŸŒ¾", "ğŸ‘©â€ğŸŒ¾", "ğŸ‘¨â€ğŸ³", "ğŸ‘©â€ğŸ³", "ğŸ‘¨â€ğŸ”§", "ğŸ‘©â€ğŸ”§", "ğŸ‘¨â€ğŸ­", "ğŸ‘©â€ğŸ­", "ğŸ‘¨â€ğŸ’¼", "ğŸ‘©â€ğŸ’¼",
		"ğŸ‘¨â€ğŸ”¬", "ğŸ‘©â€ğŸ”¬", "ğŸ‘¨â€ğŸ’»", "ğŸ‘©â€ğŸ’»", "ğŸ‘¨â€ğŸ¤", "ğŸ‘©â€ğŸ¤", "ğŸ‘¨â€ğŸ¨", "ğŸ‘©â€ğŸ¨", "ğŸ‘¨â€âœˆï¸", "ğŸ‘©â€âœˆï¸", "ğŸ‘¨â€ğŸš€", "ğŸ‘©â€ğŸš€", "ğŸ‘¨â€ğŸš’", "ğŸ‘©â€ğŸš’", "ğŸ‘®", "ğŸ•µï¸",
		"ğŸ’‚", "ğŸ‘·", "ğŸ¤´", "ğŸ‘¸", "ğŸ‘³", "ğŸ‘²", "ğŸ§•", "ğŸ¤µ", "ğŸ‘°", "ğŸ¤°", "ğŸ¤±", "ğŸ‘¼", "ğŸ…", "ğŸ¤¶", "ğŸ¦¸", "ğŸ¦¹",
	}
	cachedSorted []eData
	encodingMap  [256]string
)

func init() {
	for i, e := range EmojiAlphabet {
		if i < 256 {
			cachedSorted = append(cachedSorted, eData{e, byte(i)})
			encodingMap[i] = e
		}
	}
	sort.Slice(cachedSorted, func(i, j int) bool {
		return len(cachedSorted[i].s) > len(cachedSorted[j].s)
	})
}

func RandRead(b []byte) (int, error) {
	return rand.Read(b)
}

func DeriveKey(key string) []byte {
	hash := sha256.Sum256([]byte(key))
	return hash[:]
}

func Encrypt(data []byte, key string) ([]byte, error) {
	block, err := aes.NewCipher(DeriveKey(key))
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}
	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}
	return gcm.Seal(nonce, nonce, data, nil), nil
}

func Decrypt(ciphertext []byte, key string) ([]byte, error) {
	block, err := aes.NewCipher(DeriveKey(key))
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}
	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, errors.New("ciphertext too short")
	}
	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	return gcm.Open(nil, nonce, ciphertext, nil)
}

func EncodeToEmojis(data []byte) string {
	var sb strings.Builder
	for _, b := range data {
		sb.WriteString(encodingMap[b])
	}
	return sb.String()
}

func DecodeFromEmojis(s string) ([]byte, error) {
	sorted := getSortedAlphabet()
	var result []byte
	remaining := s
	for len(remaining) > 0 {
		found := false
		for _, ed := range sorted {
			if strings.HasPrefix(remaining, ed.s) {
				result = append(result, ed.base)
				remaining = remaining[len(ed.s):]
				found = true
				break
			}
		}
		if !found {
			return nil, errors.New("invalid emoji in payload")
		}
	}
	return result, nil
}

type eData struct {
	s    string
	base byte
}

func getSortedAlphabet() []eData {
	return cachedSorted
}

// DecodeOne reads one emoji from the reader and returns the original byte
func DecodeOne(r *bufio.Reader) (byte, error) {
	peeked, err := r.Peek(32)
	if len(peeked) == 0 {
		return 0, err
	}

	for _, ed := range cachedSorted {
		if bytes.HasPrefix(peeked, []byte(ed.s)) {
			r.Discard(len(ed.s))
			return ed.base, nil
		}
	}

	return 0, errors.New("invalid emoji sequence")
}
